#ifndef __list_
#define __list_

#include <iostream>
#include "node.h"
using namespace std;

class list {
   private:
       node *first;
       node *actual;
       //Prueba para saber si la lista está vacía
       bool emptyness(){
        return(this->first == NULL);
       }
   public:
    list(){
        this->first = NULL;
        this->actual = NULL;
    }
    //Método para insertar nodos (procesos) a la lista
    void insertar(int time, int prior, char name){
        node *nuevo = new node(prior, time,name); // Creación de un nuevo nodo
        if(emptyness()){ //Prueba para determinar si es el primer nodo o no
            this->first = nuevo; //De ser verdadera, el nodo se inserta al inicio
        } else {
            this->actual->next = nuevo; // De lo contrario, se inserta después del último nodo insertado
        }
        this->actual = nuevo; //El nuevo nodo se vuelve el último insertado
    }
    //Método para imprimir la lista después de insertar los datos
    void imprimir(){
        node *p = first; //Inicialización del nodo utilizado para recorrer la lista
        do {
            cout << p->nombre << "(" << p->tiempo << "," << p->prioridad << ")"; //Imprime la información almacenada en el nodo (Formato: Nombre(Tiempo,Prioridad).
            cout << "->"; //Flecha apuntadora al siguiente nodo
            p = p->next; //El nodo de recorrido avanza al siguiente nodo
        } while(p != NULL);
        cout << "NULL" << endl; //Impresión de NULL para indicar el final de la lista
    }
    /*void metodoFIFO(){
        if(!emptyness()){
            node *p = first;
            int TRs = 0;
            impresionFIFO();
            do{
                TRs += p->tiempo;
                p = p->next;
            } while(p != NULL);
        } else {
            cout << "Lista vacía." << endl;
        }
    }*/
    //Método para realizar la impresión por algoritmo FIFO, con tiempos de retorno
    void impresionFIFO(){
        if(!emptyness()){ //Prueba lógica para evitar errores en la ejecución
            int TRs = 0; //Variable para almacenar los Tiempos de Retorno de cada proceso
            node *aux = first; //Nodo auxiliar para avanzar la impresión
            node *p; //Nodo de recorrido de la lista para impresión de la misma
            do {
                p = aux; //Establecer el nodo de recorrido al nodo por procesar
                do{
                    cout << p->nombre << "(" << p->tiempo << "," << p->prioridad << ")"; //Impresión del nodo (Formato: Nombre(Tiempo,Prioridad)).
                    cout << "->"; //Flecha apuntadora al siguiente nodo
                    p = p->next; //El nodo de recorrido avanza al siguiente nodo.
                } while(p != NULL);
                cout << "NULL" << endl; //Impresión de NULL para indicar el final de la lista.
                TRs = TRs + aux->tiempo; //Se guarda el nuevo tiempo de retorno para cada proceso, sumando su tiempo a los tiempos de los anteriores
                cout << endl << "Tiempo de retorno de " << aux->nombre << ": " << TRs << endl; //Impresión del tiempo de retorno del nodo procesado
                aux = aux->next; //Avanza el nodo auxiliar para indicar el siguiente nodo a procesar
            } while (aux != NULL);
        } else {
            cout << "Lista vacia." << endl; //De otra manera, se imprime que la lista está vacía para evitar crash del programa
        }
    }

    //Método para impresión del algoritmo Round-Robin
    void metodoRR(int quantum){ //Recibe como parámetro el quantum, que resulta como promedio de los tiempos ingresados a lo largo de la captura
        if(!emptyness()){ //Prueba lógica para comprobar que la lista no está vacía; de ser verdadera, procede con la impresión
            int TRs = 0; //Declaración de la variable para almacenar los tiempos de retorno
            node *p = first; //Inicialización del nodo que recorre la lista
            do {
                if(p->tiempo <= quantum){ //Prueba lógica para determinar si el quantum asignado es suficiente para procesar el nodo. De cumplirse:
                    impresionRR(p); //Muestra la lista de nodos a procesar
                    TRs += p->tiempo; //Aumenta el tiempo de retorno del proceso
                    cout << "Tiempo de retorno de " << p->nombre << ": " << TRs << endl; //Muestra en pantalla el tiempo de retorno del proceso
                    p = p->next; //El nodo de recorrido avanza al siguiente nodo
                } else { //De no cumplirse:
                    impresionRR(p); //Muestra la lista de nodos a procesar
                    TRs += quantum; //Aumenta a los tiempos de retorno el quantum
                    int newTime = p->tiempo - quantum; //Calcula el tiempo restante para procesar al nodo
                    insertar(newTime, p->prioridad, p->nombre); //Añade el nodo al final de la lista para procesarlo posteriormente
                    p = p->next; //El nodo empleado para el recorrido avanza al siguiente nodo
                }
            } while(p != NULL);
        }
    }
    //Método para mostrar en pantalla la lista de procesos para el método Round-Robin
    void impresionRR(node *inicial){ //La función recibe como parámetro el nodo desde el cual comenzará a mostrar (el cual es el nodo a procesar)
        node *p = inicial; //Inicializa un nuevo nodo para realizar el recorrido
            do{
                cout << p->nombre << "(" << p->tiempo << "," << p->prioridad << ")"; //Muestra el nodo actual
                cout << "->"; //Muestra la flecha que apunta al siguiente nodo
                p = p->next; //Avanza el nodo de recorrido al siguiente nodo
            } while(p != NULL);
            cout << "NULL" << endl; // Muestra NULL en pantalla, indicando el final de la lista.
    }
    //Método para insertar datos de manera ordenada (tomando como argumento para el ordenamiento el tiempo requerido)
    void insertarSJF(int tiempo, int prioridad, char nombre){
        node *nuevo = new node(prioridad, tiempo, nombre); //Creación del nodo a insertar
        if(emptyness()){ //Si la lista está vacía, establece el nodo creado como primer nodo de la lista
            this->first = nuevo;
            this->actual = first; //Establece el nodo creado como el último nodo insertado
        } else if(nuevo->tiempo < first->tiempo){ // De otro modo, si el tiempo del nuevo nodo es menor al del primero
            nuevo->next = first; //Se establece el nuevo nodo como primer nodo, recorriendo la lista hacia la derecha
            this->first = nuevo;
        } else if(nuevo->tiempo > actual->tiempo){ //De otro modo, si el tiempo del nuevo nodo es mayor al del último nodo, se agrega el nodo al final
            this->actual->next = nuevo;
            this->actual = nuevo;
        } else { // De otro modo, se recorre la lista hasta que el nodo se pueda posicionar entre uno con menor tiempo y uno con mayor tiempo que el nodo recién creado
            node *q = first; //Nodo principal
            node *r = q->next; //Nodo auxiliar
            do {

                if(nuevo->tiempo > q->tiempo && nuevo->tiempo < r->tiempo){ //Si el tiempo del nuevo nodo es mayor al anterior y menor al siguiente
                    nuevo->next = r; //Se inserta el nodo entre esos nodos
                    q->next = nuevo;
                } else{
                    q = q->next; //De otra manera continúa recorriendo la lista
                    r = r->next;
                }
            } while(r->next != NULL); //Se repite mientras el nodo secundario no sea nulo

        }
        /*
        node *p = first;
        do {
            cout << p->nombre << "(" << p->tiempo << "," << p->prioridad << ")";
            cout << "->";
            p = p->next;
        } while(p!=NULL);
        cout << "NULL" << endl;
    }

};

#endif // __list_
